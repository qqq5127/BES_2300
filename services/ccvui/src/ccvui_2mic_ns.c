#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arm_math.h>
#include "plat_types.h"
#include "hal_trace.h"
#include "hal_timer.h"
#include "speech_cfg.h"
#include "ccvui.h"
#include "norflash_drv.h"

#if defined(CCVUI_2MIC_NS0)||defined(CCVUI_2MIC_NS1)||defined(CCVUI_2MIC_NS2)

#define CCVUI_CLS_HEAP		(10296)
//#define CCVUI_RNN_HEAP		(14624)
#define CCVUI_RNN_HEAP		(10812)
#define CCVUI_BF3_HEAP		(14896)

#define CCVUI_CLS_HANDLE	(14612)
//#define CCVUI_RNN_HANDLE  	(17576)
//#define CCVUI_RNN_HANDLE  	(12320)
#define CCVUI_RNN_HANDLE  	(11272)
#define CCVUI_BF3_HANDLE	(3984)

#define IN1_SIZE	(240*2)
#define OUT_SIZE	(256*2)
#define CCVUI_UP_LEN	(128)
#define CCVUI_DN_LEN	(256)

static const q15_t ccvui_fir_coef_q15_dn[2*16]={
          90,         136,         -95,        -302,          -4,         497,         263,        -652,        -746,         641,        1514,        -262,       -2777,       -1111,        6086,       13166,
       13166,        6086,       -1111,       -2777,        -262,        1514,         641,        -746,        -652,         263,         497,          -4,        -302,         -95,         136,          90,
};

static const q15_t ccvui_fir_coef_q15_up[2*16]={
         180,         272,        -189,        -604,          -7,         995,         527,       -1303,       -1491,        1283,        3028,        -523,       -5554,       -2222,       12173,       26333,
       26333,       12173,       -2222,       -5554,        -523,        3028,        1283,       -1491,       -1303,         527,         995,          -7,        -604,        -189,         272,         180,
};

typedef struct
{
	void*  ccvui_ns0 ;
	void*  ccvui_rnn ;
	void*  ccvui_bf3 ;
	
	arm_fir_decimate_instance_q15  		fir0DN;
	q15_t								fir0_state[CCVUI_DN_LEN + 24];
	
	arm_fir_interpolate_instance_q15	fir1UP;
	q15_t								fir1_state[CCVUI_UP_LEN + 16];
	
	arm_fir_interpolate_instance_q15	fir2UP;
	q15_t								fir2_state[CCVUI_UP_LEN + 16];

	short rx_frame[OUT_SIZE*2];
	short tx_framel[OUT_SIZE];
	short tx_framer[OUT_SIZE];
	short rx_len;
	short tx_len;
	
	int sample_rate;
	int sample_ms;
	int frame_ms;
	int ch_num;
	
	int    size;
#if defined(CCVUI_2MIC_NS0)
	char   heap[CCVUI_BF3_HEAP+CCVUI_BF3_HANDLE+CCVUI_CLS_HANDLE+12];
#elif defined(CCVUI_2MIC_NS1)
	char   heap[CCVUI_BF3_HEAP+CCVUI_BF3_HANDLE+CCVUI_RNN_HANDLE+12];
#elif defined(CCVUI_2MIC_NS2)
	char   heap[CCVUI_BF3_HEAP+CCVUI_BF3_HANDLE+CCVUI_RNN_HANDLE+CCVUI_CLS_HANDLE+12];
#endif
}ccvui_nsx_t;

static ccvui_nsx_t *ccvui_nsx;

int    ccvui_password[4]={0};// The password generated by the USB dongle of ccvui is stored in flash when it is produced in the factory


static void ccvui_tx_config(ccvui_nsx_t* handle,int sample_rate, int frame_len)
{
	memset(handle,0,sizeof(ccvui_nsx_t));
		
	switch(sample_rate)
	{
		case 8000:
			handle->sample_rate = 8000;
			handle->sample_ms = frame_len/8;
			break;
		default://case 16000:
			handle->sample_rate = 16000;
			handle->sample_ms = frame_len/16;
			break;
	}
	switch(handle->sample_ms)
	{
		case 16:
			handle->ch_num=2;
			handle->frame_ms=16;
			break;
		default://case 15:
			handle->ch_num=2;
			handle->frame_ms=15;				
			break;
	}
	handle->tx_len=0;
	handle->rx_len=0;
}
void ccvui_tx_init(int sample_rate, int frame_len)
{
	uint32_t chipid[5]={0};
	getDeviceInfo(chipid);
	//norflash_get_unique_id((uint8_t *)chipid, sizeof(chipid));
	//TRACE("getDeviceInfo=%08x,%08x,%08x,%08x,%08x\n",chipid[0],chipid[1],chipid[2],chipid[3],chipid[4]);
	
	//TRACE("ccvui_tx_init(%d)\n",sizeof(ccvui_nsx_t));
	ccvui_nsx = speech_calloc(1,sizeof(ccvui_nsx_t));
	if (ccvui_nsx!=NULL)
	{
		int size = 0;
		int indx = 0;
		ccvui_tx_config(ccvui_nsx,sample_rate,frame_len);
		
#if defined(CCVUI_2MIC_NS0)
		ccvui_nsx->ccvui_bf3 = init_COHBF_Handler(ccvui_nsx->heap,&ccvui_nsx->heap[indx],&size,(int*)ccvui_password);
		indx += size;	
		set_COHBF_Param(ccvui_nsx->ccvui_bf3,0,240,0,0);
		ccvui_nsx->ccvui_ns0 = init_ClsNS_Handler(ccvui_nsx->heap,&ccvui_nsx->heap[indx],&size,(int*)ccvui_password);
		set_ClsNS_Gain(ccvui_nsx->ccvui_ns0,26);
		indx += size;
#endif
#if defined(CCVUI_2MIC_NS1)
		ccvui_nsx->ccvui_bf3 = init_COHBF_Handler(ccvui_nsx->heap,&ccvui_nsx->heap[indx],&size,(int*)ccvui_password);
		indx += size;	
		ccvui_nsx->ccvui_rnn = init_RnnNS_Handler(ccvui_nsx->heap,&ccvui_nsx->heap[indx],&size,(int*)ccvui_password);
		indx += size;
#endif
#if defined(CCVUI_2MIC_NS2)
		ccvui_nsx->ccvui_bf3 = init_COHBF_Handler(ccvui_nsx->heap,&ccvui_nsx->heap[indx],&size,(int*)ccvui_password);
		indx += size;	
		ccvui_nsx->ccvui_rnn = init_RnnNS_Handler(ccvui_nsx->heap,&ccvui_nsx->heap[indx],&size,(int*)ccvui_password);
		indx += size;
		ccvui_nsx->ccvui_ns0 = init_ClsNS_Handler(ccvui_nsx->heap,&ccvui_nsx->heap[indx],&size,(int*)ccvui_password);
		set_ClsNS_Gain(ccvui_nsx->ccvui_ns0,26);
		indx += size;
#endif

		arm_fir_decimate_init_q15(&ccvui_nsx->fir0DN,24,2,     ccvui_fir_coef_q15_dn,ccvui_nsx->fir0_state,CCVUI_DN_LEN);
		arm_fir_interpolate_init_q15(&ccvui_nsx->fir1UP,2,16*2,ccvui_fir_coef_q15_up,ccvui_nsx->fir1_state,CCVUI_UP_LEN);
		arm_fir_interpolate_init_q15(&ccvui_nsx->fir2UP,2,16*2,ccvui_fir_coef_q15_up,ccvui_nsx->fir2_state,CCVUI_UP_LEN);
		
		//TRACE("CCVUI.ccvui_nsx=%p.\n",ccvui_nsx);
	}else{
		//TRACE("CCVUI.Malloc failed.\n");
	}
}

static void ccvui_process_16k16ms(short *in_ear,short *in_mouth, short *out, int in_len)
{
#if defined(CCVUI_2MIC_NS0)
	if (ccvui_nsx->ccvui_bf3!=NULL) make_COHBF_Process(ccvui_nsx->ccvui_bf3,in_ear,in_mouth,out);
	if (ccvui_nsx->ccvui_ns0!=NULL) make_ClsNS_Process(ccvui_nsx->ccvui_ns0,out,out);
#endif
#if defined(CCVUI_2MIC_NS1)
	if (ccvui_nsx->ccvui_bf3!=NULL) make_COHBF_Process(ccvui_nsx->ccvui_bf3,in_ear,in_mouth,out);
	if (ccvui_nsx->ccvui_rnn!=NULL) make_RnnNS_Process(ccvui_nsx->ccvui_rnn,out,out);
#endif
#if defined(CCVUI_2MIC_NS2)
	if (ccvui_nsx->ccvui_bf3!=NULL) make_COHBF_Process(ccvui_nsx->ccvui_bf3,in_ear,in_mouth,out);
	if (ccvui_nsx->ccvui_ns0!=NULL) make_ClsNS_Process(ccvui_nsx->ccvui_ns0,out,out);
	if (ccvui_nsx->ccvui_rnn!=NULL) make_RnnNS_Process(ccvui_nsx->ccvui_rnn,out,out);
#endif
}
static void ccvui_process_16k16ms_x(short *pcm_buf, short *outl,short *outr, int in_len)
{
	//TRACE("ccvui_process_16k16ms_x(%d).\n",in_len);
	int i;
	short *in_ear = outl;
	short *in_mouth = outr;
	for (i=0;i<CCVUI_DN_LEN;i++)
	{
		in_ear[i]   = pcm_buf[2*i+1];
		in_mouth[i] = pcm_buf[2*i+0];
	}
	ccvui_process_16k16ms(in_ear,in_mouth,outl,CCVUI_DN_LEN);
}
static void ccvui_process_16k15ms(short *pcm_buf, short *ref_buf, int in_len)
{
	//TRACE("ccvui_process_16k15ms(%d)480.\n",in_len);
	memcpy(&ccvui_nsx->rx_frame[ccvui_nsx->rx_len],pcm_buf,in_len*sizeof(short));
	ccvui_nsx->rx_len += in_len;
	
	if (ccvui_nsx->tx_len>=(in_len/2)) 
	{
		memcpy(pcm_buf,ccvui_nsx->tx_framel,sizeof(short)*in_len/2);
		memcpy(&pcm_buf[in_len/2],ccvui_nsx->tx_framer,sizeof(short)*in_len/2);
		ccvui_nsx->tx_len -= in_len/2;
		memcpy(ccvui_nsx->tx_framel,&ccvui_nsx->tx_framel[in_len/2],ccvui_nsx->tx_len*sizeof(short));
		memcpy(ccvui_nsx->tx_framer,&ccvui_nsx->tx_framer[in_len/2],ccvui_nsx->tx_len*sizeof(short));
		return;
	}
	
	if (ccvui_nsx->rx_len<OUT_SIZE) return;

	ccvui_process_16k16ms_x(ccvui_nsx->rx_frame,&ccvui_nsx->tx_framel[ccvui_nsx->tx_len],&ccvui_nsx->tx_framer[ccvui_nsx->tx_len],OUT_SIZE);
	
	ccvui_nsx->rx_len -= OUT_SIZE;
	memcpy(ccvui_nsx->rx_frame,&ccvui_nsx->rx_frame[OUT_SIZE],ccvui_nsx->rx_len*sizeof(short));

	ccvui_nsx->tx_len += OUT_SIZE/2;
	memcpy(pcm_buf,ccvui_nsx->tx_framel,sizeof(short)*in_len/2);
	memcpy(&pcm_buf[in_len/2],ccvui_nsx->tx_framer,sizeof(short)*in_len/2);
	ccvui_nsx->tx_len -= in_len/2;
	memcpy(ccvui_nsx->tx_framel,&ccvui_nsx->tx_framel[in_len/2],ccvui_nsx->tx_len*sizeof(short));
	memcpy(ccvui_nsx->tx_framer,&ccvui_nsx->tx_framer[in_len/2],ccvui_nsx->tx_len*sizeof(short));
}


static void ccvui_process_8k16ms(short *pcm_buf, short *outl,short *outr, int in_len)
{
	int i;
	short pcm_buf_tmp[CCVUI_DN_LEN];
	short *in_ear_8k   = &pcm_buf_tmp[0];
	short *in_mouth_8k = &pcm_buf_tmp[CCVUI_UP_LEN];
	short in_ear_16k[CCVUI_DN_LEN];
	short in_mouth_16k[CCVUI_DN_LEN];
	for (i=0;i<CCVUI_UP_LEN;i++)
	{
		in_ear_8k[i]    = pcm_buf[2*i+1];
		in_mouth_8k[i]  = pcm_buf[2*i+0];
	}
	
	arm_fir_interpolate_q15(&ccvui_nsx->fir1UP,in_ear_8k,  in_ear_16k,CCVUI_UP_LEN);
	arm_fir_interpolate_q15(&ccvui_nsx->fir2UP,in_mouth_8k,in_mouth_16k,CCVUI_UP_LEN);
	
	ccvui_process_16k16ms(in_ear_16k,in_mouth_16k,pcm_buf_tmp,in_len);
	
	arm_fir_decimate_q15(&ccvui_nsx->fir0DN,(q15_t*)pcm_buf_tmp,(q15_t*)outl,CCVUI_DN_LEN);
	memcpy(outr,outl,sizeof(short)*CCVUI_DN_LEN);
}

static void ccvui_process_8k15ms(short *pcm_buf, short *ref_buf, int in_len)
{
	memcpy(&ccvui_nsx->rx_frame[ccvui_nsx->rx_len],pcm_buf,in_len*sizeof(short));
	ccvui_nsx->rx_len += in_len;
	
	if (ccvui_nsx->tx_len>=(in_len/2)) 
	{
		memcpy(pcm_buf,ccvui_nsx->tx_framel,sizeof(short)*in_len/2);
		memcpy(&pcm_buf[in_len/2],ccvui_nsx->tx_framer,sizeof(short)*in_len/2);
		ccvui_nsx->tx_len -= in_len/2;
		memcpy(ccvui_nsx->tx_framel,&ccvui_nsx->tx_framel[in_len/2],ccvui_nsx->tx_len*sizeof(short));
		memcpy(ccvui_nsx->tx_framer,&ccvui_nsx->tx_framer[in_len/2],ccvui_nsx->tx_len*sizeof(short));
		return;
	}
	
	if (ccvui_nsx->rx_len<(OUT_SIZE/2)) return;

	ccvui_process_8k16ms(ccvui_nsx->rx_frame,&ccvui_nsx->tx_framel[ccvui_nsx->tx_len],&ccvui_nsx->tx_framer[ccvui_nsx->tx_len],OUT_SIZE/2);
	
	ccvui_nsx->rx_len -= OUT_SIZE/2;
	memcpy(ccvui_nsx->rx_frame,&ccvui_nsx->rx_frame[OUT_SIZE/2],ccvui_nsx->rx_len*sizeof(short));

	ccvui_nsx->tx_len += (OUT_SIZE/4);
	
	memcpy(pcm_buf,ccvui_nsx->tx_framel,sizeof(short)*in_len/2);
	memcpy(&pcm_buf[in_len/2],ccvui_nsx->tx_framer,sizeof(short)*in_len/2);
	ccvui_nsx->tx_len -= in_len/2;
	memcpy(ccvui_nsx->tx_framel,&ccvui_nsx->tx_framel[in_len/2],ccvui_nsx->tx_len*sizeof(short));
	memcpy(ccvui_nsx->tx_framer,&ccvui_nsx->tx_framer[in_len/2],ccvui_nsx->tx_len*sizeof(short));
}

void ccvui_tx_process(short *pcm_buf, short *ref_buf, int *_pcm_len)
{
#if 0
	int i;
	int pcm_len = *_pcm_len;
	static uint32_t frame_cnt=0;
	
	if (frame_cnt<666)
	{
		//10s slince
		memset(pcm_buf,0,pcm_len);
		frame_cnt++;
	}else if (frame_cnt<(3334+666))
	{
		//50s  left channel
		frame_cnt++;
		for (i=0;i<pcm_len/2;i++)
		{
			pcm_buf[i] = pcm_buf[2*i+0];
			ref_buf[i] = pcm_buf[2*i+1];
		}
		memcpy(&pcm_buf[pcm_len/2],ref_buf,sizeof(short)*pcm_len/2);
	}else if (frame_cnt<(3334+666+333))
	{
		//5s slince
		memset(pcm_buf,0,pcm_len);
		frame_cnt++;

	}else if (frame_cnt<(3334+666+333+3334))
	{
		//50s right channel
		frame_cnt++;
		for (i=0;i<pcm_len/2;i++)
		{
			ref_buf[i] = pcm_buf[2*i+0];
			pcm_buf[i] = pcm_buf[2*i+1];
		}
		memcpy(&pcm_buf[pcm_len/2],ref_buf,sizeof(short)*pcm_len/2);
	}else{
		//repeat
		memset(pcm_buf,0,pcm_len);
		frame_cnt = 0;
	}
	*_pcm_len = pcm_len/2;
#else
	int pcm_len = *_pcm_len;
	if(ccvui_nsx!=NULL)
	{
		//if(ccvui_nsx->ch_num!=2) {TRACE("ccvui_tx_process.ch_num!=2.\n");return;}
		if(ccvui_nsx->sample_rate==8000)
		{
			switch(ccvui_nsx->frame_ms)
			{
				case 15:ccvui_process_8k15ms(pcm_buf,ref_buf,pcm_len);break;
				case 16:ccvui_process_8k16ms(pcm_buf,pcm_buf,ref_buf,pcm_len);break;
			}
		}else{
			switch(ccvui_nsx->frame_ms)
			{
				case 15:ccvui_process_16k15ms(pcm_buf,ref_buf,pcm_len);break;
				case 16:ccvui_process_16k16ms_x(pcm_buf,pcm_buf,ref_buf,pcm_len);break;
			}
		}
	}else{
		//TRACE("ccvui_tx_process.ccvui_heap=NULL.\n");
	}
	*_pcm_len = pcm_len;
#endif	
}

void ccvui_tx_exit(void)
{
	//TRACE("ccvui_tx_exit\n");
	if(ccvui_nsx!=NULL)
	{
		speech_free(ccvui_nsx);
		ccvui_nsx = NULL;
	}
}
#endif 