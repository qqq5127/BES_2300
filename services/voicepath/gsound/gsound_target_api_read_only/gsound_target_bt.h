// Copyright 2018 Google LLC.
// Libgsound version: 5a34367
#ifndef GSOUND_TARGET_BT_H
#define GSOUND_TARGET_BT_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * This header file was generated by Google GSound Services,
 * it should not be altered in any way. Please treat this as
 * a read-only file.
 *
 * Each function listed below must
 * be implemented for each specific
 * platform / SDK
 *
 */
#include "gsound_target.h"

/**
 * Bluetooth Description
 *
 * At a high level GSound requires SPP/RFCOMM connections to a remote
 * device. The most common implementation of GSound requires 2 concurrent
 * channels; one for CONTROL and another for AUDIO. However, it is possible that
 * this changes in a future release.
 *
 * Refer to the GSoundChannelType enumeration for the latest list of required
 * channel(s).
 *
 * For SPP/RFCOMM, GSound is the Server or "Type 1" or "DevB" device
 * (depending on which specification you read). This means it must register
 * itself with the local SDP Server. The remote device (phone) will query the
 * local SDP server to discover these channels.
 *
 * Tx buffers are owned by the GSound library.
 * GSound will allocate its own buffer to store Tx data, and free it only
 * after Target has indicated that transmission is complete.
 *
 * Rx buffers are owned by the Target.
 * Target can only free Rx buffers after GSound has indicated that the data
 * has been fully consumed.
 *
 *
 */

/*******************************************************************************
 * Type definitions
 ******************************************************************************/
/**
 * Maximum size of a phone number in bytes
 */
#define GSOUND_TARGET_BT_HFP_NUMBER_MAX 21

/**
 * Type definition containing a phone number
 * which will be used to dial over HFP
 */
typedef struct {
  // length in bytes of the number
  uint8_t size;
  // An ASCII string containing the number to be dialed
  uint8_t number[GSOUND_TARGET_BT_HFP_NUMBER_MAX];
} GSoundTargetBtHfpNumber;

/**
 * Type definition containing a phone number
 * which will be used to send an sms over MAP
 */
typedef struct {
  // length in bytes of the number
  uint32_t size;
  // An ASCII encoded byte array, this array will not be null terminated
  const uint8_t *number;
} GSoundTargetBtMapSmsNumber;

typedef enum {
  MESSAGE_ENCODING_8_BIT = 0,  // 8-bit clear encoding
  MESSAGE_ENCODING_UNICODE,    // 16-bit UNICODE encoding
} GSoundBtMapMessageEcoding;

/**
 * Type definition containing a message
 * which will be used to send an sms over MAP
 */
typedef struct {
  // contains the ecoding used to encode themessage
  GSoundBtMapMessageEcoding encoding;
  // length in bytes of the number
  uint32_t size;
  // byte array containing the message body. (not null terminated)
  const uint8_t *message;
} GSoundTargetBtMapSmsMessage;

typedef enum {
  GSOUND_TARGET_BT_LINK_DISCONNECTED,
  GSOUND_TARGET_BT_LINK_CONNECTED
} GSoundBtLinkState;

/*******************************************************************************
 * SDP UUID Definitions
 ******************************************************************************/

/**
 * The follow defines the 128-bit UUID (Big Endian):
 * f8d1fbe4-7966-4334-8024-ff96c9330e15.
 *
 * This macro should be used directly or the contents
 * replicated in the Target layer to form the SDP
 * Service Record for the CONTROL Channel
 */
#define GSOUND_BT_CONTROL_SDP_UUID                                        \
  0x15, 0x0e, 0x33, 0xc9, 0x96, 0xff, 0x24, 0x80, 0x34, 0x43, 0x66, 0x79, \
      0xe4, 0xfb, 0xd1, 0xf8

/**
 * The follow defines the 128-bit UUID (Big Endian):
 * 81c2e72a-0591-443e-a1ff-05f988593351.
 *
 * This macro should be used directly or the contents
 * replicated in the Target layer to form the SDP
 * Service Record for the CONTROL Channel
 */
#define GSOUND_BT_AUDIO_SDP_UUID                                          \
  0x51, 0x33, 0x59, 0x88, 0xf9, 0x05, 0xff, 0xa1, 0x3e, 0x44, 0x91, 0x05, \
      0x2a, 0xe7, 0xc2, 0x81

/*******************************************************************************
 * Following declares the standard BT
 * Interface API.
 ******************************************************************************/
typedef struct {
  /**
   * Callback which should be executed by Target to Synchronously indicate
   * that a channel connection indication has been received from remote side.
   *
   * Depending on the return value of this function, Target should either
   * Accept the  incoming connection or Reject it. See return values below
   *
   *
   * Multi-Threaded Environment:
   *    - This method is a blocking call that waits on a Mutex. Therefore this
   *      method is not ISR safe.
   *
   * Returns GSOUND_STATUS_OK       if the connection should be allowed
   *         GSOUND_STATUS_ERROR    if the connection should not be allowed.
   */
  GSoundStatus (*gsound_bt_on_connect_ind)(GSoundChannelType channel,
                                           const GSoundBTAddr *addr);

  /**
   * Callback which should be executed by Target when the SPP channel
   * connection is fully establish and data is ready to be exchanged.
   *
   * This function is non-blocking and thread safe. It can be called from any
   * thread/context including an ISR.
   */
  GSoundStatus (*gsound_bt_on_connected)(GSoundChannelType channel,
                                         const GSoundBTAddr *addr);

  /**
   * Callback which should be executed by Target to Synchronously indicate
   * that a channel has been disconnected.
   *
   * Target should call this any time one of the GSound SPP channels
   * has been disconnected for any reason
   *
   * Multi-Threaded Environment:
   *    - This method is a blocking call that waits on a Mutex. Therefore this
   *      method is not ISR safe.
   *
   * Returns GSOUND_STATUS_ERROR if the channel is not currently connected and
   * GSOUND_STATUS_OK otherwise.
   */
  GSoundStatus (*gsound_bt_on_channel_disconnect)(GSoundChannelType channel);

  /**
   * Callback which should be executed by Target when the BT Link to
   * any remote device has changed from connected to disconnected
   * (or vice versa).
   *
   * Note, this callback deals with the main BT Link between two devices.
   * It is unrelated to SPP/RFCOMM connections/disconnection events.
   * For example, this callback should execute if BT was disabled
   * on a remote device whether or not an SPP/RFCOMM connection was present
   * at the time.
   *
   * This function is non-blocking and thread safe. It can be called from any
   * thread/context including an ISR.
   *
   * param[in]: link_state  New state of the BT link
   * param[in]: addr        Public BD_ADDR of remote device which
   *                        connected/disconnected
   */
  GSoundStatus (*gsound_bt_on_link_change)(GSoundBtLinkState link_state,
                                           const GSoundBTAddr *addr);

  /**
   * Callback which should be executed to indicate that the GSound buffer used
   * to transmit data (without making a copy) has been consumed and is free to
   * be released.
   *
   * This callback should not be executed if target made a copy of tx data
   * before transmitting.
   *
   * Target must provide the `channel` `data` and `length` parameters to
   * gsound_bt_on_tx_consumed which exact match the `channel` `data` and
   * `length` parameters passed to GSoundTargetBtTransmit.
   *
   *
   * This function is non-blocking and thread safe. It can be called from any
   * thread/context including an ISR.
   */
  GSoundStatus (*gsound_bt_on_tx_consumed)(GSoundChannelType channel,
                                           const uint8_t *data,
                                           uint32_t length);

  /**
   * Callback which should be executed by Target when there is transmit space
   * available for an SPP channel. This call is required if a call to
   * GSoundTargetBtTransmit failed to consume or queue all of the data. See
   * GSoundTargetBtTransmit for more information.
   *
   * This function is non-blocking and thread safe. It can be called from any
   * thread/context including an ISR.
   */
  GSoundStatus (*gsound_bt_on_tx_available)(GSoundChannelType channel);

  /**
   * Callback which should be executed by Target when data has been
   * received from remote device.
   *
   * Target must provide a pointer to a buffer containing the data which was
   * received along with its length and the specific channel.
   *
   * GSound will consume this data asynchronously from within the provided
   * buffer. Therefore Target cannot free this buffer after this call
   * returns. Instead, Target must reserve the buffer for GSound to use
   * until GSound calls GSoundTargetBtRxComplete
   *
   * This function is non-blocking and thread safe. It can be called from any
   * thread/context including an ISR.
   *
   */
  GSoundStatus (*gsound_bt_on_rx_ready)(GSoundChannelType channel,
                                        const uint8_t *data, uint32_t len);
} GSoundBtInterface;

/*******************************************************************************
 * Function declarations
 ******************************************************************************/

/**
 * Initiate a phone call by dialing the number provided
 * by function over HFP.
 *
 * In case of Multi-Point, the HFP Dial command should be
 * routed to the phone with an active Google Assistant as provided
 * by the gsound_addr parameter.
 *
 * Note the data pointed to by number and gsound_addr must be fully consumed
 * before this function returns. Target cannot point to this
 * data after returning from this function.
 *
 * param[in]: number  Pointer to the phone number to dial. Refer to the
 *                    GSoundTargetBtHfpNumber type for details
 *
 * param[in]: gsound_addr Pointer to BD_ADDR of Phone with Google Assistant
 *                        active.
 *
 */
GSoundStatus GSoundTargetBtHfpDial(const GSoundTargetBtHfpNumber *number,
                                   const GSoundBTAddr *gsound_addr);

/**
 * Use the MAP bt classic profile to send an sms to an iOS device
 *
 * In case of Multi-Point, the MAP sms command should be
 * routed to the phone with an active Google Assistant as provided
 * by the gsound_addr parameter.
 *
 * Note the data pointed to by number and gsound_addr must be fully consumed
 * before this function returns. Target cannot point to this
 * data after returning from this function.
 *
 * param[in]: number  Pointer to the phone number to send the sms to. Refer to
 * the GSoundTargetBtMapSmsNumber type for details
 *
 * param[in]: message  Pointer to the message to send. Refer to the
 *                    GSoundTargetBtMapSmsMessage type for details
 *
 * param[in]: gsound_addr Pointer to BD_ADDR of Phone with Google Assistant
 *                        active.
 *
 */
GSoundStatus GSoundTargetBtMapSendSms(
    const GSoundTargetBtMapSmsNumber *number,
    const GSoundTargetBtMapSmsMessage *message,
    const GSoundBTAddr *gsound_addr);

/**
 * Returns max number of bytes supported
 * by RFCOMM. This value must be the same for all channels.
 *
 * The returned value must exclude any header bytes required by RFCOMM from the
 * L2CAP MTU.
 *
 * Note that GSound expects MTU to always be non-zero.  If, however, the target
 * does return an MTU of zero at some point and later returns the MTU to a
 * non-zero value without a disconnect, it must send
 * gsound_bt_on_tx_available() when MTU is changed from zero to non-zero. This
 * prevents transmit stalls within GSound.
 */
uint16_t GSoundTargetBtGetMtu(void);

/**
 * Returns true/false depending on whether the device
 * referenced by the provided BD_ADDR is connected over BT or not
 *
 * param[in]: gsound_addr BD_ADDR of device in question
 *
 * returns:   true  If device provided is connected over BT
 *            false If device provided is not connected over BT
 */

bool GSoundTargetBtIsConnected(GSoundBTAddr const *gsound_addr);

/**
 * Callback from GSound to Target platform. This function will be called
 * by GSound when the buffer passed to GSound from Target via
 * the GSoundBtInterface.gsound_bt_on_rx_ready(...) has been processed
 * and the memory can be freed by target.
 *
 * For example:
 *    - gsound_bt_on_rx_ready(...) --> to GSound will start consuming buffer
 *      ...
 *    - (GSound still consuming buffer))
 *      ...
 *    - (GSound done using buffer)
 *    - GSoundTargetBtRxComplete(...) --> To Target, ready to free buffer
 *    - (Target frees buffer)
 */
void GSoundTargetBtRxComplete(GSoundChannelType type, const uint8_t *buffer,
                              uint32_t len);

/**
 * Target should pause A2DP stream, if A2DP stream is active, from secondary BT
 * connection. Where secondary BT connection is a multi-point connection to a
 * device (i.e. phone, PC, etc.) without an active Google Assistant.
 *
 * The non-GSound device is any BT connection to device which does
 * not match the BD_ADDR provided by gsound_addr parameter.
 *
 * Target is required to internally maintain the pause/resume state of the
 * secondary device in order to properly resume when
 * GSoundTargetBtResumeSecondary() is called.
 *
 * param[in]: gsound_addr Pointer to BD_ADDR of GSound Device
 */
GSoundStatus GSoundTargetBtPauseSecondary(const GSoundBTAddr *gsound_addr);

/**
 * Target should resume A2DP stream from secondary BT connection if it was
 * previously paused by a call to GSoundTargetBtPauseSecondary(). Where
 * secondary BT connection is a multi-point connection to a device (i.e. phone,
 * PC, etc.) without an active Google Assistant.
 *
 * Target is required to internally maintain the pause/resume state
 * when GSoundTargetBtPauseSecondary() is called.
 *
 * param[in]: gsound_addr Pointer to BD_ADDR of GSound Device
 */
GSoundStatus GSoundTargetBtResumeSecondary(const GSoundBTAddr *gsound_addr);

/**
 * Return the total number of classic BT devices currently connected.
 */
uint8_t GSoundTargetBtNumDevicesConnected(void);

/**
 * Returns state of HFP.
 * True if active, otherwise false
 *
 * In case of Multi-Point, this API should return True
 * if HFP is active on any phone connected to the headset.
 *
 */
bool GSoundTargetBtHfpIsActive(void);

/**
 * Transmit a BT Packet over the provided channel.
 *
 * The target can choose to transmit the data directly from the GSound buffer
 * (without making a copy), or immediately make a copy before returning from
 * this function.
 *
 * If a copy is made, Target must set the `bytes_consumed` parameter to the
 * number of bytes copied before returning.
 *
 * If a copy is not made, Target must call the function
 * GSoundBtInterface.gsound_bt_on_tx_consumed(channel, data, length) at some
 * later time.
 *
 * param[in]:  channel GSound channel to send data on.
 * param[in]:  data    Pointer to an array of `length` bytes
 * param[in]:  length  Number of bytes to send. This value will be no more than
 *                     one MTU (as reported by GSoundTargetBtGetMtu)
 * param[out]: bytes_consumed Target must set this value to the number of bytes
 *                            consumed or copied before transmitting. If the
 *                            data is transmitted without making a copy, set
 *                            this value to 0.
 *
 * return:
 *    GSOUND_STATUS_OK:            If all `length` bytes of data has been
 *                                 successfully queued or consumed for
 *                                 transmission.
 *
 *    GSOUND_STATUS_OUT_OF_MEMORY: If less than `length` bytes could be consumed
 *                                 or queued by Target for transmission. In this
 *                                 case Target must call
 *                                 GSoundBtInterface.gsound_bt_on_tx_available()
 *                                 when memory is available.
 *    GSOUND_STATUS_ERROR:         If any other error occurs.
 */
GSoundStatus GSoundTargetBtTransmit(GSoundChannelType channel,
                                    const uint8_t *data, uint32_t length,
                                    uint32_t *bytes_consumed);

/**
 * Close the SPP/RFCOMM channel specified by GSound
 */
GSoundStatus GSoundTargetBtChannelClose(GSoundChannelType channel);

/**
 * Initialize and create SPP/RFCOMM Type 1 (i.e. server, end-point)
 * connection(s). In addition, this function must also register
 * the channels with the local SDP server. Refer to the UUIDs
 * in this file.
 *
 * Note: The channels should be as a SDP service record using the
 * standard format for SPP i.e. SPP over RFCOMM over L2CAP.
 *
 * Target is required to establish and maintain the number of channels
 * as defined by GSoundChannelType.GSOUND_NUM_CHANNEL_TYPES.
 *
 * NOTE: for TWS, should not advertise unless master.
 */
GSoundStatus GSoundTargetBtInit(const GSoundBtInterface *handler);

#ifdef __cplusplus
}
#endif

#endif  // GSOUND_TARGET_BT_H
