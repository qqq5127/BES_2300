/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: dma.proto */

#ifndef PROTOBUF_C_dma_2eproto__INCLUDED
#define PROTOBUF_C_dma_2eproto__INCLUDED

#include "protobuf-c.h"

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1003001 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif


typedef struct _ControlEnvelope ControlEnvelope;
typedef struct _Response Response;
typedef struct _Dialog Dialog;
typedef struct _SpeechInitiator SpeechInitiator;
typedef struct _SpeechInitiator__WakeWord SpeechInitiator__WakeWord;
typedef struct _SpeechSettings SpeechSettings;
typedef struct _StartSpeech StartSpeech;
typedef struct _ProvideSpeech ProvideSpeech;
typedef struct _SpeechProvider SpeechProvider;
typedef struct _StopSpeech StopSpeech;
typedef struct _EndPointSpeech EndPointSpeech;
typedef struct _NotifySpeechState NotifySpeechState;
typedef struct _DeviceInformation DeviceInformation;
typedef struct _PairInformation PairInformation;
typedef struct _DeviceConfiguration DeviceConfiguration;
typedef struct _GetDeviceInformation GetDeviceInformation;
typedef struct _GetDeviceConfiguration GetDeviceConfiguration;
typedef struct _NotifyDeviceConfiguration NotifyDeviceConfiguration;
typedef struct _State State;
typedef struct _GetState GetState;
typedef struct _SetState SetState;
typedef struct _SynchronizeState SynchronizeState;
typedef struct _ForwardATCommand ForwardATCommand;
typedef struct _ForwardTestCommand ForwardTestCommand;
typedef struct _IssueMediaControl IssueMediaControl;


/* --- enums --- */

typedef enum _SpeechInitiator__Type {
  SPEECH_INITIATOR__TYPE__NONE = 0,
  SPEECH_INITIATOR__TYPE__PRESS_AND_HOLD = 1,
  SPEECH_INITIATOR__TYPE__TAP = 3,
  SPEECH_INITIATOR__TYPE__WAKEWORD = 4
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SPEECH_INITIATOR__TYPE)
} SpeechInitiator__Type;
/*
 * //////////////////////////////////////////////////////////////////////////////
 * 传输层类型。当前还不支持iAP。
 */
typedef enum _Transport {
  TRANSPORT__BLUETOOTH_LOW_ENERGY = 0,
  TRANSPORT__BLUETOOTH_RFCOMM = 1,
  TRANSPORT__BLUETOOTH_IAP = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TRANSPORT)
} Transport;
/*
 * 错误代码类型。
 */
typedef enum _ErrorCode {
  ERROR_CODE__SUCCESS = 0,
  ERROR_CODE__UNKNOWN = 1,
  ERROR_CODE__INTERNAL = 2,
  ERROR_CODE__UNSUPPORTED = 3,
  ERROR_CODE__USER_CANCELLED = 4,
  ERROR_CODE__NOT_FOUND = 5,
  ERROR_CODE__INVALID = 6,
  ERROR_CODE__BUSY = 7,
  /*
   *Pair的错误返回：已经被配对了
   */
  ERROR_CODE__NOT_IN_PAIR_MODE = 8,
  /*
   *签名验证失败
   */
  ERROR_CODE__SIGN_VERIFY_FAIL = 9
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(ERROR_CODE)
} ErrorCode;
/*
 * 控制指令类型。
 */
typedef enum _Command {
  /*
   *Speech Recognition
   */
  COMMAND__PROVIDE_SPEECH = 0,
  COMMAND__PROVIDE_SPEECH_ACK = 1,
  COMMAND__START_SPEECH = 2,
  COMMAND__START_SPEECH_ACK = 3,
  COMMAND__STOP_SPEECH = 4,
  COMMAND__STOP_SPEECH_ACK = 5,
  COMMAND__END_POINT_SPEECH = 6,
  COMMAND__END_POINT_SPEECH_ACK = 7,
  COMMAND__NOTIFY_SPEECH_STATE = 8,
  COMMAND__NOTIFY_SPEECH_STATE_ACK = 9,
  /*
   *Device
   */
  COMMAND__GET_DEVICE_INFORMATION = 20,
  COMMAND__GET_DEVICE_INFORMATION_ACK = 21,
  COMMAND__GET_DEVICE_CONFIGURATION = 22,
  COMMAND__GET_DEVICE_CONFIGURATION_ACK = 23,
  COMMAND__NOTIFY_DEVICE_CONFIGURATION = 24,
  COMMAND__NOTIFY_DEVICE_CONFIGURATION_ACK = 25,
  COMMAND__PAIR = 26,
  COMMAND__PAIR_ACK = 27,
  /*
   *State
   */
  COMMAND__GET_STATE = 30,
  COMMAND__GET_STATE_ACK = 31,
  COMMAND__SET_STATE = 32,
  COMMAND__SET_STATE_ACK = 33,
  COMMAND__SYNCHRONIZE_STATE = 34,
  COMMAND__SYNCHRONIZE_STATE_ACK = 35,
  /*
   *Cellular calling
   */
  COMMAND__FORWARD_AT_COMMAND = 40,
  COMMAND__FORWARD_AT_COMMAND_ACK = 41,
  /*
   *Test command
   */
  COMMAND__FORWARD_TEST_COMMAND = 42,
  COMMAND__FORWARD_TEST_COMMAND_ACK = 43,
  /*
   *Media
   */
  COMMAND__ISSUE_MEDIA_CONTROL = 44,
  COMMAND__ISSUE_MEDIA_CONTROL_ACK = 45
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(COMMAND)
} Command;
typedef enum _AudioSource {
  AUDIO_SOURCE__STREAM = 0
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(AUDIO_SOURCE)
} AudioSource;
typedef enum _AudioProfile {
  AUDIO_PROFILE__CLOSE_TALK = 0,
  AUDIO_PROFILE__NEAR_FIELD = 1,
  AUDIO_PROFILE__FAR_FIELD = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(AUDIO_PROFILE)
} AudioProfile;
typedef enum _AudioFormat {
  AUDIO_FORMAT__PCM_L16_16KHZ_MONO = 0,
  AUDIO_FORMAT__OPUS_16KHZ_32KBPS_CBR_0_20MS = 1,
  AUDIO_FORMAT__OPUS_16KHZ_16KBPS_CBR_0_20MS = 2,
  AUDIO_FORMAT__MSBC = 3,
  AUDIO_FORMAT__SPEEX_16KHZ_16KBPS = 4,
  AUDIO_FORMAT__SBC_16KHZ_MONO_16KBPS_28BITPOOL_16NUMBLOCKS_8SUBBANDS_SNR = 5
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(AUDIO_FORMAT)
} AudioFormat;
typedef enum _SpeechState {
  SPEECH_STATE__IDLE = 0,
  SPEECH_STATE__LISTENING = 1,
  SPEECH_STATE__PROCESSING = 2,
  SPEECH_STATE__SPEAKING = 3
    //PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SPEECH_STATE)
} SpeechState;
typedef enum _InitiatorType {
  /*
   *可选的值："PRESS_AND_HOLD", "TAP", "PHONE_WAKEUP"
   */
  INITIATOR_TYPE__PRESS_AND_HOLD = 0,
  INITIATOR_TYPE__TAP = 1,
  INITIATOR_TYPE__PHONE_WAKEUP = 2,
  INITIATOR_TYPE__WAIT_FOLLOW_WAKEUP = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(INITIATOR_TYPE)
} InitiatorType;
typedef enum _SignMethod {
  SIGN_METHOD__SHA256 = 0,
  SIGN_METHOD__SHA1 = 1,
  /*
   *不建议使用
   */
  SIGN_METHOD__MD5SUM = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(SIGN_METHOD)
} SignMethod;
typedef enum _MediaControl {
  MEDIA_CONTROL__PLAY = 0,
  MEDIA_CONTROL__PAUSE = 1,
  MEDIA_CONTROL__NEXT = 2,
  MEDIA_CONTROL__PREVIOUS = 3,
  MEDIA_CONTROL__ABSOLUTE_VOLUME = 4
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(MEDIA_CONTROL)
} MediaControl;

/* --- messages --- */

typedef enum {
  CONTROL_ENVELOPE__PAYLOAD__NOT_SET = 0,
  CONTROL_ENVELOPE__PAYLOAD_RESPONSE = 9,
  CONTROL_ENVELOPE__PAYLOAD_PROVIDE_SPEECH = 21,
  CONTROL_ENVELOPE__PAYLOAD_START_SPEECH = 22,
  CONTROL_ENVELOPE__PAYLOAD_STOP_SPEECH = 23,
  CONTROL_ENVELOPE__PAYLOAD_END_POINT_SPEECH = 24,
  CONTROL_ENVELOPE__PAYLOAD_NOTIFY_SPEECH_STATE = 25,
  CONTROL_ENVELOPE__PAYLOAD_GET_DEVICE_INFORMATION = 26,
  CONTROL_ENVELOPE__PAYLOAD_GET_DEVICE_CONFIGURATION = 27,
  CONTROL_ENVELOPE__PAYLOAD_NOTIFY_DEVICE_CONFIGURATION = 28,
  CONTROL_ENVELOPE__PAYLOAD_GET_STATE = 29,
  CONTROL_ENVELOPE__PAYLOAD_SET_STATE = 30,
  CONTROL_ENVELOPE__PAYLOAD_SYNCHRONIZE_STATE = 31,
  CONTROL_ENVELOPE__PAYLOAD_FORWARD_ATCOMMAND = 32,
  CONTROL_ENVELOPE__PAYLOAD_FORWARD_TEST_COMMAND = 33,
  CONTROL_ENVELOPE__PAYLOAD_ISSUE_MEDIA_CONTROL = 34
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(CONTROL_ENVELOPE__PAYLOAD)
} ControlEnvelope__PayloadCase;

/*
 * //////////////////////////////////////////////////////////////////////////////
 * 控制指令封装
 * 每一个发送到控制流的信息都需要被包在ControlEnvelope里面。详细定义如下。
 */
struct  _ControlEnvelope
{
  ProtobufCMessage base;
  Command command;
  /*
   *主动发起的command，带上这个参数，Ack的command会照原样带回来，建议长度不超过6个字节
   */
  char *request_id;
  /*
   *sign2与rand2皆为可选字段，用于手机发起的指令的签名，在外设对此字段做相应的鉴权操作，具体清空README.md中关于鉴权的描述
   *目前仅有PROVIDE_SPEECH和GET_STATE(ENTER_OTA_MODE)需要带sign2字段
   *sign2 = sha256(rand2 + rand + key + product\_id + serial\_number)
   *签名算法需要使用PairInformation中的SignMethod
   *起名sign2和rand2是为了区分PairInformation中的sign和rand
   */
  char *sign2;
  /*
   *可选
   */
  char *rand2;
  ControlEnvelope__PayloadCase payload_case;
  union {
    Response *response;
    /*
     *command messages
     */
    ProvideSpeech *providespeech;
    StartSpeech *startspeech;
    StopSpeech *stopspeech;
    EndPointSpeech *endpointspeech;
    NotifySpeechState *notifyspeechstate;
    GetDeviceInformation *getdeviceinformation;
    GetDeviceConfiguration *getdeviceconfiguration;
    NotifyDeviceConfiguration *notifydeviceconfiguration;
    GetState *getstate;
    SetState *setstate;
    SynchronizeState *synchronizestate;
    ForwardATCommand *forwardatcommand;
    ForwardTestCommand *forwardtestcommand;
    /*
     *Media, mapping avrcp
     */
    IssueMediaControl *issue_media_control;
  };
};
#define CONTROL_ENVELOPE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&control_envelope__descriptor) \
    , COMMAND__PROVIDE_SPEECH, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, CONTROL_ENVELOPE__PAYLOAD__NOT_SET, {0} }


typedef enum {
  RESPONSE__PAYLOAD__NOT_SET = 0,
  RESPONSE__PAYLOAD_SPEECH_PROVIDER = 11,
  RESPONSE__PAYLOAD_DEVICE_INFORMATION = 12,
  RESPONSE__PAYLOAD_DEVICE_CONFIGURATION = 13,
  RESPONSE__PAYLOAD_STATE = 14,
  RESPONSE__PAYLOAD_PAIR_INFORMATION = 15
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(RESPONSE__PAYLOAD)
} Response__PayloadCase;

/*
 * 每一个发送到控制流的控制指令都需要有一个回复（ACK）。
 */
struct  _Response
{
  ProtobufCMessage base;
  ErrorCode error_code;
  Response__PayloadCase payload_case;
  union {
    SpeechProvider *speechprovider;
    DeviceInformation *deviceinformation;
    DeviceConfiguration *deviceconfiguration;
    State *state;
    PairInformation *pairinformation;
  };
};
#define RESPONSE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&response__descriptor) \
    , ERROR_CODE__SUCCESS, RESPONSE__PAYLOAD__NOT_SET, {0} }


/*
 * //////////////////////////////////////////////////////////////////////////////
 * 能力：语音识别
 */
struct  _Dialog
{
  ProtobufCMessage base;
  uint32_t id;
};
#define DIALOG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&dialog__descriptor) \
    , 0 }


struct  _SpeechInitiator__WakeWord
{
  ProtobufCMessage base;
  uint32_t start_index_in_samples;
  uint32_t end_index_in_samples;
};
#define SPEECH_INITIATOR__WAKE_WORD__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&speech_initiator__wake_word__descriptor) \
    , 0, 0 }


struct  _SpeechInitiator
{
  ProtobufCMessage base;
  SpeechInitiator__Type type;
  SpeechInitiator__WakeWord *wake_word;
  /*
   *控制手机端是否播放唤醒提示音
   */
  protobuf_c_boolean play_prompt_tone;
};
#define SPEECH_INITIATOR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&speech_initiator__descriptor) \
    , SPEECH_INITIATOR__TYPE__NONE, NULL, 0 }


struct  _SpeechSettings
{
  ProtobufCMessage base;
  AudioProfile audio_profile;
  AudioFormat audio_format;
  AudioSource audio_source;
};
#define SPEECH_SETTINGS__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&speech_settings__descriptor) \
    , AUDIO_PROFILE__CLOSE_TALK, AUDIO_FORMAT__PCM_L16_16KHZ_MONO, AUDIO_SOURCE__STREAM }


struct  _StartSpeech
{
  ProtobufCMessage base;
  SpeechSettings *settings;
  SpeechInitiator *initiator;
  Dialog *dialog;
};
#define START_SPEECH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&start_speech__descriptor) \
    , NULL, NULL, NULL }


struct  _ProvideSpeech
{
  ProtobufCMessage base;
  Dialog *dialog;
};
#define PROVIDE_SPEECH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&provide_speech__descriptor) \
    , NULL }


struct  _SpeechProvider
{
  ProtobufCMessage base;
  SpeechSettings *settings;
  Dialog *dialog;
};
#define SPEECH_PROVIDER__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&speech_provider__descriptor) \
    , NULL, NULL }


struct  _StopSpeech
{
  ProtobufCMessage base;
  ErrorCode error_code;
  Dialog *dialog;
};
#define STOP_SPEECH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&stop_speech__descriptor) \
    , ERROR_CODE__SUCCESS, NULL }


struct  _EndPointSpeech
{
  ProtobufCMessage base;
  Dialog *dialog;
};
#define END_POINT_SPEECH__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&end_point_speech__descriptor) \
    , NULL }


struct  _NotifySpeechState
{
  ProtobufCMessage base;
  SpeechState state;
};
#define NOTIFY_SPEECH_STATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&notify_speech_state__descriptor) \
    , SPEECH_STATE__IDLE }


/*
 * //////////////////////////////////////////////////////////////////////////////
 * 能力：设备信息
 */
struct  _DeviceInformation
{
  ProtobufCMessage base;
  char *serial_number;
  const char *name;
  size_t n_supported_transports;
  Transport *supported_transports;
  /*
   *default "3P" //HEADPHONE, SPEAKER, DOCK
   */
  const char *device_type;
  size_t n_supported_audio_formats;
  AudioFormat *supported_audio_formats;
  /*
   *厂商
   */
  const char *manufacturer;
  /*
   *型号
   */
  char *model;
  const char *firmware_version;
  const char *software_version;
  /*
   *设备支持的语音交互方式
   */
  InitiatorType initiator_type;
  /*
   *产品id需要从度秘平台获得, 为空的时候，判定设备为UNKONWN或者OTHER。 长度不超过32字节
   */
  const char *product_id;
  /*
   *类似06:36:3b:cd:c1:b0
   */
  char *classic_bluetooth_mac;
  /*
   *移动到了PairInformation，为了不引起兼容问题，以下13、14不要再使用了
   *string rand=13;//长度8位的随机字符串。注意：需要每次返回都不一样。具体逻辑请看README.md中的鉴权部分
   *string sign=14;//sign = sha256(rand + key + product_id + serial_number),  key需要从度秘平台获得。具体逻辑请看README.md中的鉴权部分
   */
  /*
   *如果这个字段为false，手机端会每1-2秒发一个GET_STATE的请求，作为设备的心跳包。设为true的时候，手机不发送心跳请求
   */
  protobuf_c_boolean disable_heart_beat;
  /*
   *如果这个字段为true，手机端生成sign2的时候会做第二次hash, new_sign2 = sign_method ( sign2 + requestId + int2string(command))，具体逻辑请看README.md中的“高级安全”部分
   */
  protobuf_c_boolean enable_advanced_security;
  /*
   *可选，默认为false；标识设备是否使用FM发射的方式播放音频。如果这个字段为true。app连接外设成功之后会触发fm发射频率设置的逻辑。
   */
  protobuf_c_boolean support_fm;
  /*
   *可选，标识外设上负责ota软件的版本。ota的软件和实现功能的软件（software_version）是独立的，所以版本号也独立
   */
  char *ota_version;
  /*
   *如果这个字段为true，手机端不再强制要求当前a2dp输出的设备，和dma设备是同一个设备
   */
  protobuf_c_boolean no_a2dp;
  /*
   *如果这个字段为true，设备不支持DMA的ForwardATCommand指令，这样小度app在尝试帮用户拨打电话的时候，不会使用ForwardATCommand，而是使用ios或安卓系统的拨号api
   */
  protobuf_c_boolean no_at_command;
  /*
   *如果这个字段为true，设备支持DMA的Media能力。这样小度app在执行音量调整的时候，会发送IssueMediaControl指令。在小度app收到用户的“下一首”之类的query的时候，如果当前没有媒体播放，会尝试用IssueMediaControl指令控制手机上的其它播放器。
   */
  protobuf_c_boolean support_media;
};
#define DEVICE_INFORMATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&device_information__descriptor) \
    , (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, 0,NULL, (char *)protobuf_c_empty_string, 0,NULL, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, INITIATOR_TYPE__PRESS_AND_HOLD, (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, 0, 0, 0, (char *)protobuf_c_empty_string, 0, 0, 0 }


struct  _PairInformation
{
  ProtobufCMessage base;
  /*
   *长度8位的随机字符串。注意：需要每次返回都不一样，一旦返回后，需要把这个值保存下来，供ProvideSpeech的签名验证使用。具体逻辑请看README.md中的鉴权部分
   */
  char *rand;
  /*
   *sign = sha256(rand + key + product_id + serial_number),  key需要从度秘平台获得。具体逻辑请看README.md中的鉴权部分
   */
  char *sign;
  /*
   *签名算法
   */
  SignMethod signmethod;
};
#define PAIR_INFORMATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&pair_information__descriptor) \
    , (char *)protobuf_c_empty_string, (char *)protobuf_c_empty_string, SIGN_METHOD__SHA256 }


struct  _DeviceConfiguration
{
  ProtobufCMessage base;
  /*
   *现在都是false，不需要
   */
  protobuf_c_boolean needs_assistant_override;
  protobuf_c_boolean needs_setup;
};
#define DEVICE_CONFIGURATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&device_configuration__descriptor) \
    , 0, 0 }


struct  _GetDeviceInformation
{
  ProtobufCMessage base;
};
#define GET_DEVICE_INFORMATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&get_device_information__descriptor) \
     }


struct  _GetDeviceConfiguration
{
  ProtobufCMessage base;
};
#define GET_DEVICE_CONFIGURATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&get_device_configuration__descriptor) \
     }


struct  _NotifyDeviceConfiguration
{
  ProtobufCMessage base;
};
#define NOTIFY_DEVICE_CONFIGURATION__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&notify_device_configuration__descriptor) \
     }


typedef enum {
  STATE__VALUE__NOT_SET = 0,
  STATE__VALUE_BOOLEAN = 2,
  STATE__VALUE_INTEGER = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(STATE__VALUE)
} State__ValueCase;

struct  _State
{
  ProtobufCMessage base;
  uint32_t feature;
  State__ValueCase value_case;
  union {
    protobuf_c_boolean boolean;
    uint32_t integer;
  };
};
#define STATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&state__descriptor) \
    , 0, STATE__VALUE__NOT_SET, {0} }


struct  _GetState
{
  ProtobufCMessage base;
  uint32_t feature;
};
#define GET_STATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&get_state__descriptor) \
    , 0 }


struct  _SetState
{
  ProtobufCMessage base;
  State *state;
};
#define SET_STATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&set_state__descriptor) \
    , NULL }


struct  _SynchronizeState
{
  ProtobufCMessage base;
  State *state;
};
#define SYNCHRONIZE_STATE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&synchronize_state__descriptor) \
    , NULL }


struct  _ForwardATCommand
{
  ProtobufCMessage base;
  char *command;
};
#define FORWARD_ATCOMMAND__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&forward_atcommand__descriptor) \
    , (char *)protobuf_c_empty_string }


struct  _ForwardTestCommand
{
  ProtobufCMessage base;
  char *command;
};
#define FORWARD_TEST_COMMAND__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&forward_test_command__descriptor) \
    , (char *)protobuf_c_empty_string }


struct  _IssueMediaControl
{
  ProtobufCMessage base;
  MediaControl control;
  /*
   *0-100, 只有control == ABSOLUTE_VOLUME的时候生效。
   */
  uint32_t volume;
};
#define ISSUE_MEDIA_CONTROL__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&issue_media_control__descriptor) \
    , MEDIA_CONTROL__PLAY, 0 }


/* ControlEnvelope methods */
void   control_envelope__init
                     (ControlEnvelope         *message);
size_t control_envelope__get_packed_size
                     (const ControlEnvelope   *message);
size_t control_envelope__pack
                     (const ControlEnvelope   *message,
                      uint8_t             *out);
size_t control_envelope__pack_to_buffer
                     (const ControlEnvelope   *message,
                      ProtobufCBuffer     *buffer);
ControlEnvelope *
       control_envelope__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   control_envelope__free_unpacked
                     (ControlEnvelope *message,
                      ProtobufCAllocator *allocator);
/* Response methods */
void   response__init
                     (Response         *message);
size_t response__get_packed_size
                     (const Response   *message);
size_t response__pack
                     (const Response   *message,
                      uint8_t             *out);
size_t response__pack_to_buffer
                     (const Response   *message,
                      ProtobufCBuffer     *buffer);
Response *
       response__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   response__free_unpacked
                     (Response *message,
                      ProtobufCAllocator *allocator);
/* Dialog methods */
void   dialog__init
                     (Dialog         *message);
size_t dialog__get_packed_size
                     (const Dialog   *message);
size_t dialog__pack
                     (const Dialog   *message,
                      uint8_t             *out);
size_t dialog__pack_to_buffer
                     (const Dialog   *message,
                      ProtobufCBuffer     *buffer);
Dialog *
       dialog__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   dialog__free_unpacked
                     (Dialog *message,
                      ProtobufCAllocator *allocator);
/* SpeechInitiator__WakeWord methods */
void   speech_initiator__wake_word__init
                     (SpeechInitiator__WakeWord         *message);
/* SpeechInitiator methods */
void   speech_initiator__init
                     (SpeechInitiator         *message);
size_t speech_initiator__get_packed_size
                     (const SpeechInitiator   *message);
size_t speech_initiator__pack
                     (const SpeechInitiator   *message,
                      uint8_t             *out);
size_t speech_initiator__pack_to_buffer
                     (const SpeechInitiator   *message,
                      ProtobufCBuffer     *buffer);
SpeechInitiator *
       speech_initiator__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   speech_initiator__free_unpacked
                     (SpeechInitiator *message,
                      ProtobufCAllocator *allocator);
/* SpeechSettings methods */
void   speech_settings__init
                     (SpeechSettings         *message);
size_t speech_settings__get_packed_size
                     (const SpeechSettings   *message);
size_t speech_settings__pack
                     (const SpeechSettings   *message,
                      uint8_t             *out);
size_t speech_settings__pack_to_buffer
                     (const SpeechSettings   *message,
                      ProtobufCBuffer     *buffer);
SpeechSettings *
       speech_settings__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   speech_settings__free_unpacked
                     (SpeechSettings *message,
                      ProtobufCAllocator *allocator);
/* StartSpeech methods */
void   start_speech__init
                     (StartSpeech         *message);
size_t start_speech__get_packed_size
                     (const StartSpeech   *message);
size_t start_speech__pack
                     (const StartSpeech   *message,
                      uint8_t             *out);
size_t start_speech__pack_to_buffer
                     (const StartSpeech   *message,
                      ProtobufCBuffer     *buffer);
StartSpeech *
       start_speech__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   start_speech__free_unpacked
                     (StartSpeech *message,
                      ProtobufCAllocator *allocator);
/* ProvideSpeech methods */
void   provide_speech__init
                     (ProvideSpeech         *message);
size_t provide_speech__get_packed_size
                     (const ProvideSpeech   *message);
size_t provide_speech__pack
                     (const ProvideSpeech   *message,
                      uint8_t             *out);
size_t provide_speech__pack_to_buffer
                     (const ProvideSpeech   *message,
                      ProtobufCBuffer     *buffer);
ProvideSpeech *
       provide_speech__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   provide_speech__free_unpacked
                     (ProvideSpeech *message,
                      ProtobufCAllocator *allocator);
/* SpeechProvider methods */
void   speech_provider__init
                     (SpeechProvider         *message);
size_t speech_provider__get_packed_size
                     (const SpeechProvider   *message);
size_t speech_provider__pack
                     (const SpeechProvider   *message,
                      uint8_t             *out);
size_t speech_provider__pack_to_buffer
                     (const SpeechProvider   *message,
                      ProtobufCBuffer     *buffer);
SpeechProvider *
       speech_provider__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   speech_provider__free_unpacked
                     (SpeechProvider *message,
                      ProtobufCAllocator *allocator);
/* StopSpeech methods */
void   stop_speech__init
                     (StopSpeech         *message);
size_t stop_speech__get_packed_size
                     (const StopSpeech   *message);
size_t stop_speech__pack
                     (const StopSpeech   *message,
                      uint8_t             *out);
size_t stop_speech__pack_to_buffer
                     (const StopSpeech   *message,
                      ProtobufCBuffer     *buffer);
StopSpeech *
       stop_speech__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   stop_speech__free_unpacked
                     (StopSpeech *message,
                      ProtobufCAllocator *allocator);
/* EndPointSpeech methods */
void   end_point_speech__init
                     (EndPointSpeech         *message);
size_t end_point_speech__get_packed_size
                     (const EndPointSpeech   *message);
size_t end_point_speech__pack
                     (const EndPointSpeech   *message,
                      uint8_t             *out);
size_t end_point_speech__pack_to_buffer
                     (const EndPointSpeech   *message,
                      ProtobufCBuffer     *buffer);
EndPointSpeech *
       end_point_speech__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   end_point_speech__free_unpacked
                     (EndPointSpeech *message,
                      ProtobufCAllocator *allocator);
/* NotifySpeechState methods */
void   notify_speech_state__init
                     (NotifySpeechState         *message);
size_t notify_speech_state__get_packed_size
                     (const NotifySpeechState   *message);
size_t notify_speech_state__pack
                     (const NotifySpeechState   *message,
                      uint8_t             *out);
size_t notify_speech_state__pack_to_buffer
                     (const NotifySpeechState   *message,
                      ProtobufCBuffer     *buffer);
NotifySpeechState *
       notify_speech_state__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   notify_speech_state__free_unpacked
                     (NotifySpeechState *message,
                      ProtobufCAllocator *allocator);
/* DeviceInformation methods */
void   device_information__init
                     (DeviceInformation         *message);
size_t device_information__get_packed_size
                     (const DeviceInformation   *message);
size_t device_information__pack
                     (const DeviceInformation   *message,
                      uint8_t             *out);
size_t device_information__pack_to_buffer
                     (const DeviceInformation   *message,
                      ProtobufCBuffer     *buffer);
DeviceInformation *
       device_information__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   device_information__free_unpacked
                     (DeviceInformation *message,
                      ProtobufCAllocator *allocator);
/* PairInformation methods */
void   pair_information__init
                     (PairInformation         *message);
size_t pair_information__get_packed_size
                     (const PairInformation   *message);
size_t pair_information__pack
                     (const PairInformation   *message,
                      uint8_t             *out);
size_t pair_information__pack_to_buffer
                     (const PairInformation   *message,
                      ProtobufCBuffer     *buffer);
PairInformation *
       pair_information__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   pair_information__free_unpacked
                     (PairInformation *message,
                      ProtobufCAllocator *allocator);
/* DeviceConfiguration methods */
void   device_configuration__init
                     (DeviceConfiguration         *message);
size_t device_configuration__get_packed_size
                     (const DeviceConfiguration   *message);
size_t device_configuration__pack
                     (const DeviceConfiguration   *message,
                      uint8_t             *out);
size_t device_configuration__pack_to_buffer
                     (const DeviceConfiguration   *message,
                      ProtobufCBuffer     *buffer);
DeviceConfiguration *
       device_configuration__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   device_configuration__free_unpacked
                     (DeviceConfiguration *message,
                      ProtobufCAllocator *allocator);
/* GetDeviceInformation methods */
void   get_device_information__init
                     (GetDeviceInformation         *message);
size_t get_device_information__get_packed_size
                     (const GetDeviceInformation   *message);
size_t get_device_information__pack
                     (const GetDeviceInformation   *message,
                      uint8_t             *out);
size_t get_device_information__pack_to_buffer
                     (const GetDeviceInformation   *message,
                      ProtobufCBuffer     *buffer);
GetDeviceInformation *
       get_device_information__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   get_device_information__free_unpacked
                     (GetDeviceInformation *message,
                      ProtobufCAllocator *allocator);
/* GetDeviceConfiguration methods */
void   get_device_configuration__init
                     (GetDeviceConfiguration         *message);
size_t get_device_configuration__get_packed_size
                     (const GetDeviceConfiguration   *message);
size_t get_device_configuration__pack
                     (const GetDeviceConfiguration   *message,
                      uint8_t             *out);
size_t get_device_configuration__pack_to_buffer
                     (const GetDeviceConfiguration   *message,
                      ProtobufCBuffer     *buffer);
GetDeviceConfiguration *
       get_device_configuration__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   get_device_configuration__free_unpacked
                     (GetDeviceConfiguration *message,
                      ProtobufCAllocator *allocator);
/* NotifyDeviceConfiguration methods */
void   notify_device_configuration__init
                     (NotifyDeviceConfiguration         *message);
size_t notify_device_configuration__get_packed_size
                     (const NotifyDeviceConfiguration   *message);
size_t notify_device_configuration__pack
                     (const NotifyDeviceConfiguration   *message,
                      uint8_t             *out);
size_t notify_device_configuration__pack_to_buffer
                     (const NotifyDeviceConfiguration   *message,
                      ProtobufCBuffer     *buffer);
NotifyDeviceConfiguration *
       notify_device_configuration__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   notify_device_configuration__free_unpacked
                     (NotifyDeviceConfiguration *message,
                      ProtobufCAllocator *allocator);
/* State methods */
void   state__init
                     (State         *message);
size_t state__get_packed_size
                     (const State   *message);
size_t state__pack
                     (const State   *message,
                      uint8_t             *out);
size_t state__pack_to_buffer
                     (const State   *message,
                      ProtobufCBuffer     *buffer);
State *
       state__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   state__free_unpacked
                     (State *message,
                      ProtobufCAllocator *allocator);
/* GetState methods */
void   get_state__init
                     (GetState         *message);
size_t get_state__get_packed_size
                     (const GetState   *message);
size_t get_state__pack
                     (const GetState   *message,
                      uint8_t             *out);
size_t get_state__pack_to_buffer
                     (const GetState   *message,
                      ProtobufCBuffer     *buffer);
GetState *
       get_state__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   get_state__free_unpacked
                     (GetState *message,
                      ProtobufCAllocator *allocator);
/* SetState methods */
void   set_state__init
                     (SetState         *message);
size_t set_state__get_packed_size
                     (const SetState   *message);
size_t set_state__pack
                     (const SetState   *message,
                      uint8_t             *out);
size_t set_state__pack_to_buffer
                     (const SetState   *message,
                      ProtobufCBuffer     *buffer);
SetState *
       set_state__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   set_state__free_unpacked
                     (SetState *message,
                      ProtobufCAllocator *allocator);
/* SynchronizeState methods */
void   synchronize_state__init
                     (SynchronizeState         *message);
size_t synchronize_state__get_packed_size
                     (const SynchronizeState   *message);
size_t synchronize_state__pack
                     (const SynchronizeState   *message,
                      uint8_t             *out);
size_t synchronize_state__pack_to_buffer
                     (const SynchronizeState   *message,
                      ProtobufCBuffer     *buffer);
SynchronizeState *
       synchronize_state__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   synchronize_state__free_unpacked
                     (SynchronizeState *message,
                      ProtobufCAllocator *allocator);
/* ForwardATCommand methods */
void   forward_atcommand__init
                     (ForwardATCommand         *message);
size_t forward_atcommand__get_packed_size
                     (const ForwardATCommand   *message);
size_t forward_atcommand__pack
                     (const ForwardATCommand   *message,
                      uint8_t             *out);
size_t forward_atcommand__pack_to_buffer
                     (const ForwardATCommand   *message,
                      ProtobufCBuffer     *buffer);
ForwardATCommand *
       forward_atcommand__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   forward_atcommand__free_unpacked
                     (ForwardATCommand *message,
                      ProtobufCAllocator *allocator);
/* ForwardTestCommand methods */
void   forward_test_command__init
                     (ForwardTestCommand         *message);
size_t forward_test_command__get_packed_size
                     (const ForwardTestCommand   *message);
size_t forward_test_command__pack
                     (const ForwardTestCommand   *message,
                      uint8_t             *out);
size_t forward_test_command__pack_to_buffer
                     (const ForwardTestCommand   *message,
                      ProtobufCBuffer     *buffer);
ForwardTestCommand *
       forward_test_command__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   forward_test_command__free_unpacked
                     (ForwardTestCommand *message,
                      ProtobufCAllocator *allocator);
/* IssueMediaControl methods */
void   issue_media_control__init
                     (IssueMediaControl         *message);
size_t issue_media_control__get_packed_size
                     (const IssueMediaControl   *message);
size_t issue_media_control__pack
                     (const IssueMediaControl   *message,
                      uint8_t             *out);
size_t issue_media_control__pack_to_buffer
                     (const IssueMediaControl   *message,
                      ProtobufCBuffer     *buffer);
IssueMediaControl *
       issue_media_control__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   issue_media_control__free_unpacked
                     (IssueMediaControl *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*ControlEnvelope_Closure)
                 (const ControlEnvelope *message,
                  void *closure_data);
typedef void (*Response_Closure)
                 (const Response *message,
                  void *closure_data);
typedef void (*Dialog_Closure)
                 (const Dialog *message,
                  void *closure_data);
typedef void (*SpeechInitiator__WakeWord_Closure)
                 (const SpeechInitiator__WakeWord *message,
                  void *closure_data);
typedef void (*SpeechInitiator_Closure)
                 (const SpeechInitiator *message,
                  void *closure_data);
typedef void (*SpeechSettings_Closure)
                 (const SpeechSettings *message,
                  void *closure_data);
typedef void (*StartSpeech_Closure)
                 (const StartSpeech *message,
                  void *closure_data);
typedef void (*ProvideSpeech_Closure)
                 (const ProvideSpeech *message,
                  void *closure_data);
typedef void (*SpeechProvider_Closure)
                 (const SpeechProvider *message,
                  void *closure_data);
typedef void (*StopSpeech_Closure)
                 (const StopSpeech *message,
                  void *closure_data);
typedef void (*EndPointSpeech_Closure)
                 (const EndPointSpeech *message,
                  void *closure_data);
typedef void (*NotifySpeechState_Closure)
                 (const NotifySpeechState *message,
                  void *closure_data);
typedef void (*DeviceInformation_Closure)
                 (const DeviceInformation *message,
                  void *closure_data);
typedef void (*PairInformation_Closure)
                 (const PairInformation *message,
                  void *closure_data);
typedef void (*DeviceConfiguration_Closure)
                 (const DeviceConfiguration *message,
                  void *closure_data);
typedef void (*GetDeviceInformation_Closure)
                 (const GetDeviceInformation *message,
                  void *closure_data);
typedef void (*GetDeviceConfiguration_Closure)
                 (const GetDeviceConfiguration *message,
                  void *closure_data);
typedef void (*NotifyDeviceConfiguration_Closure)
                 (const NotifyDeviceConfiguration *message,
                  void *closure_data);
typedef void (*State_Closure)
                 (const State *message,
                  void *closure_data);
typedef void (*GetState_Closure)
                 (const GetState *message,
                  void *closure_data);
typedef void (*SetState_Closure)
                 (const SetState *message,
                  void *closure_data);
typedef void (*SynchronizeState_Closure)
                 (const SynchronizeState *message,
                  void *closure_data);
typedef void (*ForwardATCommand_Closure)
                 (const ForwardATCommand *message,
                  void *closure_data);
typedef void (*ForwardTestCommand_Closure)
                 (const ForwardTestCommand *message,
                  void *closure_data);
typedef void (*IssueMediaControl_Closure)
                 (const IssueMediaControl *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCEnumDescriptor    transport__descriptor;
extern const ProtobufCEnumDescriptor    error_code__descriptor;
extern const ProtobufCEnumDescriptor    command__descriptor;
extern const ProtobufCEnumDescriptor    audio_source__descriptor;
extern const ProtobufCEnumDescriptor    audio_profile__descriptor;
extern const ProtobufCEnumDescriptor    audio_format__descriptor;
extern const ProtobufCEnumDescriptor    speech_state__descriptor;
extern const ProtobufCEnumDescriptor    initiator_type__descriptor;
extern const ProtobufCEnumDescriptor    sign_method__descriptor;
extern const ProtobufCEnumDescriptor    media_control__descriptor;
extern const ProtobufCMessageDescriptor control_envelope__descriptor;
extern const ProtobufCMessageDescriptor response__descriptor;
extern const ProtobufCMessageDescriptor dialog__descriptor;
extern const ProtobufCMessageDescriptor speech_initiator__descriptor;
extern const ProtobufCMessageDescriptor speech_initiator__wake_word__descriptor;
extern const ProtobufCEnumDescriptor    speech_initiator__type__descriptor;
extern const ProtobufCMessageDescriptor speech_settings__descriptor;
extern const ProtobufCMessageDescriptor start_speech__descriptor;
extern const ProtobufCMessageDescriptor provide_speech__descriptor;
extern const ProtobufCMessageDescriptor speech_provider__descriptor;
extern const ProtobufCMessageDescriptor stop_speech__descriptor;
extern const ProtobufCMessageDescriptor end_point_speech__descriptor;
extern const ProtobufCMessageDescriptor notify_speech_state__descriptor;
extern const ProtobufCMessageDescriptor device_information__descriptor;
extern const ProtobufCMessageDescriptor pair_information__descriptor;
extern const ProtobufCMessageDescriptor device_configuration__descriptor;
extern const ProtobufCMessageDescriptor get_device_information__descriptor;
extern const ProtobufCMessageDescriptor get_device_configuration__descriptor;
extern const ProtobufCMessageDescriptor notify_device_configuration__descriptor;
extern const ProtobufCMessageDescriptor state__descriptor;
extern const ProtobufCMessageDescriptor get_state__descriptor;
extern const ProtobufCMessageDescriptor set_state__descriptor;
extern const ProtobufCMessageDescriptor synchronize_state__descriptor;
extern const ProtobufCMessageDescriptor forward_atcommand__descriptor;
extern const ProtobufCMessageDescriptor forward_test_command__descriptor;
extern const ProtobufCMessageDescriptor issue_media_control__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_dma_2eproto__INCLUDED */
