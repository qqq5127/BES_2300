#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arm_math.h>
#include "plat_types.h"
#include "hal_trace.h"
#include "hal_timer.h"
#include "speech_cfg.h"
#include "ccvui.h"
#include "norflash_drv.h"

#if defined(CCVUI_1MIC_NS0)||defined(CCVUI_1MIC_NS1)||defined(CCVUI_1MIC_NS2)

#define CCVUI_CLS_HEAP		(10296)
#define CCVUI_RNN_HEAP		(11200)
#define CCVUI_BF3_HEAP		(14896)

#define CCVUI_CLS_HANDLE	(14612)
//#define CCVUI_RNN_HANDLE  	(11272)
#define CCVUI_RNN_HANDLE  	(14384)
#define CCVUI_BF3_HANDLE	(3984)

#define IN1_SIZE	(240)
#define OUT_SIZE	(256)
#define CCVUI_UP_LEN	(128)
#define CCVUI_DN_LEN	(256)

static const q15_t ccvui_fir_coef_q15_dn[2*16]={
          90,         136,         -95,        -302,          -4,         497,         263,        -652,        -746,         641,        1514,        -262,       -2777,       -1111,        6086,       13166,
       13166,        6086,       -1111,       -2777,        -262,        1514,         641,        -746,        -652,         263,         497,          -4,        -302,         -95,         136,          90,
};

static const q15_t ccvui_fir_coef_q15_up[2*16]={
         180,         272,        -189,        -604,          -7,         995,         527,       -1303,       -1491,        1283,        3028,        -523,       -5554,       -2222,       12173,       26333,
       26333,       12173,       -2222,       -5554,        -523,        3028,        1283,       -1491,       -1303,         527,         995,          -7,        -604,        -189,         272,         180,
};

typedef struct
{
	void*  ccvui_ns0 ;
	void*  ccvui_rnn ;
	void*  ccvui_bf3 ;
	
	arm_fir_decimate_instance_q15  		fir0DN;
	q15_t								fir0_state[CCVUI_DN_LEN + 24];
	
	arm_fir_interpolate_instance_q15	fir1UP;
	q15_t								fir1_state[CCVUI_UP_LEN + 16];
	
	short rx_frame[OUT_SIZE*2];
	short tx_frame[OUT_SIZE*2];
	short rx_len;
	short tx_len;
	
	int sample_rate;
	int sample_ms;
	int frame_ms;
	int ch_num;
	
	int    size;
#if defined (CCVUI_1MIC_NS0)
	char   heap[CCVUI_CLS_HEAP+CCVUI_CLS_HANDLE+12];
#elif defined(CCVUI_1MIC_NS1)
	char   heap[CCVUI_RNN_HEAP+CCVUI_RNN_HANDLE+12];
#elif defined(CCVUI_1MIC_NS2)
	char   heap[CCVUI_RNN_HEAP+CCVUI_RNN_HANDLE+CCVUI_CLS_HANDLE+12];
#endif
}ccvui_nsx_t;

static ccvui_nsx_t *ccvui_nsx=NULL;



static void ccvui_tx_config(ccvui_nsx_t* handle,int sample_rate, int frame_len)
{
	memset(handle,0,sizeof(ccvui_nsx_t));
		
	switch(sample_rate)
	{
		case 8000:
			handle->sample_rate = 8000;
			handle->sample_ms = frame_len/8;
			break;
		default://case 16000:
			handle->sample_rate = 16000;
			handle->sample_ms = frame_len/16;
			break;
	}
	switch(handle->sample_ms)
	{
		case 16:
			handle->ch_num=1;
			handle->frame_ms=16;
			break;
		default://case 15:
			handle->ch_num=1;
			handle->frame_ms=15;				
			break;
	}
}
void ccvui_tx_init(int sample_rate, int frame_len)
{
	uint32_t chipid[5]={0};
	unsigned int *ccvui_password =(unsigned int *)(0x3C1FB000+24);// The password generated by the USB dongle of ccvui is stored in flash when it is produced in the factory
	getDeviceInfo(chipid);
	//norflash_get_unique_id((uint8_t *)chipid, sizeof(chipid));
	TRACE("FlashID=%08x,%08x,%08x,%08x,%08x\n",chipid[0],chipid[1],chipid[2],chipid[3],chipid[4]);
	//TRACE(5,"CCVUI[%08x]=%08x,%08x,%08x,%08x",&ccvui_password[0],ccvui_password[0],ccvui_password[1],ccvui_password[2],ccvui_password[3]); 
	//TRACE(5,"CCVUI[%08x]=%08x,%08x,%08x,%08x",&ccvui_password[4],ccvui_password[4],ccvui_password[5],ccvui_password[6],ccvui_password[7]);
	
	TRACE("ccvui_tx_init(%d)\n",sizeof(ccvui_nsx_t));
	ccvui_nsx = speech_calloc(1,sizeof(ccvui_nsx_t));
	if (ccvui_nsx!=NULL)
	{
		int size = 0;
		int indx = 0;
		ccvui_tx_config(ccvui_nsx,sample_rate,frame_len);
		
#if defined(CCVUI_1MIC_NS0)
		ccvui_nsx->ccvui_ns0 = init_ClsNS_Handler(ccvui_nsx->heap,&ccvui_nsx->heap[indx],&size,(int*)ccvui_password);
		set_ClsNS_Gain(ccvui_nsx->ccvui_ns0,26);
		indx += size;
#endif
#if defined(CCVUI_1MIC_NS1)
		ccvui_nsx->ccvui_rnn = init_RnnNS_Handler(ccvui_nsx->heap,&ccvui_nsx->heap[indx],&size,(int*)ccvui_password);
		indx += size;
#endif
#if defined(CCVUI_1MIC_NS2)
		ccvui_nsx->ccvui_rnn = init_RnnNS_Handler(ccvui_nsx->heap,&ccvui_nsx->heap[indx],&size,(int*)ccvui_password);
		indx += size;
		ccvui_nsx->ccvui_ns0 = init_ClsNS_Handler(ccvui_nsx->heap,&ccvui_nsx->heap[indx],&size,(int*)ccvui_password);
		set_ClsNS_Gain(ccvui_nsx->ccvui_ns0,26);
		indx += size;
#endif

		arm_fir_decimate_init_q15(&ccvui_nsx->fir0DN,24,2,     ccvui_fir_coef_q15_dn,ccvui_nsx->fir0_state,CCVUI_DN_LEN);
		arm_fir_interpolate_init_q15(&ccvui_nsx->fir1UP,2,16*2,ccvui_fir_coef_q15_up,ccvui_nsx->fir1_state,CCVUI_UP_LEN);
		
		
		TRACE("CCVUI.ccvui_nsx=%p.\n",ccvui_nsx);
	}else{
		TRACE("CCVUI.Malloc failed.\n");
	}
}

static void ccvui_process_16k16ms(short *in, short *out, int in_len)
{
#if defined(CCVUI_1MIC_NS0)
	if (ccvui_nsx->ccvui_ns0!=NULL) make_ClsNS_Process(ccvui_nsx->ccvui_ns0,in,out);
#endif
#if defined(CCVUI_1MIC_NS1)
	if (ccvui_nsx->ccvui_rnn!=NULL) make_RnnNS_Process(ccvui_nsx->ccvui_rnn,in,out);
#endif
#if defined(CCVUI_1MIC_NS2)
	if (ccvui_nsx->ccvui_ns0!=NULL) make_ClsNS_Process(ccvui_nsx->ccvui_ns0,in,out);
	if (ccvui_nsx->ccvui_rnn!=NULL) make_RnnNS_Process(ccvui_nsx->ccvui_rnn,out,out);
#endif
}

static void ccvui_process_16k15ms(short *pcm_buf, short *ref_buf, int in_len)
{
	memcpy(&ccvui_nsx->rx_frame[ccvui_nsx->rx_len],pcm_buf,in_len*sizeof(short));
	ccvui_nsx->rx_len += in_len;
	
	if (ccvui_nsx->tx_len>=IN1_SIZE) 
	{
		memcpy(pcm_buf,ccvui_nsx->tx_frame,IN1_SIZE*sizeof(short));
		ccvui_nsx->tx_len -= IN1_SIZE;
		memcpy(ccvui_nsx->tx_frame,&ccvui_nsx->tx_frame[IN1_SIZE],ccvui_nsx->tx_len*sizeof(short));
		return;
	}
	
	if (ccvui_nsx->rx_len<OUT_SIZE) return;

	ccvui_process_16k16ms(ccvui_nsx->rx_frame,&ccvui_nsx->tx_frame[ccvui_nsx->tx_len],OUT_SIZE);
	
	ccvui_nsx->rx_len = ccvui_nsx->rx_len - OUT_SIZE;
	memcpy(ccvui_nsx->rx_frame,&ccvui_nsx->rx_frame[OUT_SIZE],ccvui_nsx->rx_len*sizeof(short));

	ccvui_nsx->tx_len += OUT_SIZE;
	memcpy(pcm_buf,ccvui_nsx->tx_frame,IN1_SIZE*sizeof(short));
	ccvui_nsx->tx_len -= IN1_SIZE;
	memcpy(ccvui_nsx->tx_frame,&ccvui_nsx->tx_frame[IN1_SIZE],ccvui_nsx->tx_len*sizeof(short));
}


static void ccvui_process_8k16ms(short *in, short *out, int in_len)
{
	short pcm_buf_tmp[CCVUI_DN_LEN];
	arm_fir_interpolate_q15(&ccvui_nsx->fir1UP,in,pcm_buf_tmp,CCVUI_UP_LEN);
	
	ccvui_process_16k16ms(pcm_buf_tmp,pcm_buf_tmp,in_len);
	
	arm_fir_decimate_q15(&ccvui_nsx->fir0DN,(q15_t*)pcm_buf_tmp,(q15_t*)out,CCVUI_DN_LEN);
}

static void ccvui_process_8k15ms(short *pcm_buf, short *ref_buf, int in_len)
{
	memcpy(&ccvui_nsx->rx_frame[ccvui_nsx->rx_len],pcm_buf,in_len*sizeof(short));
	ccvui_nsx->rx_len += in_len;
	
	if (ccvui_nsx->tx_len>=(IN1_SIZE/2)) 
	{
		memcpy(pcm_buf,ccvui_nsx->tx_frame,(IN1_SIZE/2)*sizeof(short));
		ccvui_nsx->tx_len -= (IN1_SIZE/2);
		memcpy(ccvui_nsx->tx_frame,&ccvui_nsx->tx_frame[(IN1_SIZE/2)],ccvui_nsx->tx_len*sizeof(short));
		return;
	}
	
	if (ccvui_nsx->rx_len<(OUT_SIZE/2)) return;

	ccvui_process_8k16ms(ccvui_nsx->rx_frame,&ccvui_nsx->tx_frame[ccvui_nsx->tx_len],(OUT_SIZE/2));
	
	ccvui_nsx->rx_len = ccvui_nsx->rx_len - (OUT_SIZE/2);
	memcpy(ccvui_nsx->rx_frame,&ccvui_nsx->rx_frame[(OUT_SIZE/2)],ccvui_nsx->rx_len*sizeof(short));

	ccvui_nsx->tx_len += (OUT_SIZE/2);
	memcpy(pcm_buf,ccvui_nsx->tx_frame,(IN1_SIZE/2)*sizeof(short));
	ccvui_nsx->tx_len -= (IN1_SIZE/2);
	memcpy(ccvui_nsx->tx_frame,&ccvui_nsx->tx_frame[(IN1_SIZE/2)],ccvui_nsx->tx_len*sizeof(short));
}
static uint32_t frame_cnt=0;
void ccvui_tx_process(short *pcm_buf, short *ref_buf, int *_pcm_len)
{
	if(ccvui_nsx!=NULL)
	{
		if (++frame_cnt==64){frame_cnt=0;TRACE("ccvui_tx_process.pcm_len=%d.\n",*_pcm_len);}
		int pcm_len = *_pcm_len;
		//if(ccvui_nsx->ch_num!=1) {TRACE("ccvui_tx_process.ch_num!=1.\n");return;}
		if(ccvui_nsx->sample_rate==8000)
		{
			switch(ccvui_nsx->frame_ms)
			{
				case 15:ccvui_process_8k15ms(pcm_buf,ref_buf,pcm_len);break;
				case 16:ccvui_process_8k16ms(pcm_buf,pcm_buf,pcm_len);break;
			}
		}else{
			switch(ccvui_nsx->frame_ms)
			{
				case 15:ccvui_process_16k15ms(pcm_buf,ref_buf,pcm_len);break;
				case 16:ccvui_process_16k16ms(pcm_buf,pcm_buf,pcm_len);break;
			}
		}
	}else{
		TRACE("ccvui_tx_process.ccvui_heap=NULL.\n");
	}
}

void ccvui_tx_exit(void)
{
	TRACE("ccvui_tx_exit\n");
	if(ccvui_nsx!=NULL)
	{
		speech_free(ccvui_nsx);
		ccvui_nsx = NULL;
	}
}

#endif 