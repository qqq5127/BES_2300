// Copyright 2018 Google LLC.
// Libgsound version: 5a34367
#ifndef GSOUND_TARGET_OSA_H
#define GSOUND_TARGET_OSA_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * This header file was generated by Google GSound Services,
 * it should not be altered in any way. Please treat this as
 * a read-only file.
 *
 * Each function listed below must
 * be implemented for each specific
 * platform / SDK
 *
 */
#include "gsound.h"

/**
 * This file contains the  target API for Operating System abstractions
 * including Mutex, Semaphore, Threads, Int-locks, etc.
 */

/******************************************************************************
 * Mutexes
 ******************************************************************************/
/**
 * Number of Mutexes required
 * for GSound application.
 *
 * Target must be able to allocate GSOUND_TARGET_OS_MUTEX_MAX number
 * of Mutexes (ideally statically)
 *
 * TODO(gsound): move this macro to a GSound "application specific" layer
 *               header file since the number of mutexes required will
 *               depend on the application. Macro should still be released in
 *               source form to 3P
 */
#define GSOUND_TARGET_OS_MUTEX_MAX 3

/**
 * Generic handle to a Mutex type.
 * Target can use this to point to a memory location
 * or index into a table.
 */
typedef void *GSoundTargetMutexHandle;

/**
 * Reserve/allocate and initialize a new Mutex.
 *
 * Ideally, target layer has GSOUND_TARGET_OS_MUTEX_MAX number of mutexes
 * statically allocated at compile time. Target is also free to dynamically
 * allocate mutexes if desired.
 *
 * GSound will call this API to retrieve one of these mutexes.
 *
 * This function should return a new Mutex every time it is called until
 * it runs out at which point it should assert
 *
 * param[out]: id GSoundTargetMutexHandle opaque data type which GSound will use
 * to reference the Mutex
 */
GSoundStatus GSoundTargetOsMutexReserve(GSoundTargetMutexHandle *id);

/**
 * Wait until the Mutex provided by id is available.
 * This API should not timeout. Should never be called from ISR
 *
 * param[in]: id GSoundTargetMutexHandle opaque data type referencing
 *               Mutex to wait on
 */
GSoundStatus GSoundTargetOsMutexWait(GSoundTargetMutexHandle id);

/**
 * Release the Mutex provided by id.
 *
 * param[in]: id GSoundTargetMutexHandle opaque data type referencing
 *               Mutex to release
 */
GSoundStatus GSoundTargetOsMutexRelease(GSoundTargetMutexHandle id);

/******************************************************************************
 * Semaphores
 ******************************************************************************/
/**
 * Number of Semaphores required
 * for GSound application.
 *
 * Target must be able to allocate GSOUND_TARGET_OS_SEMAPHORE_MAX number
 * of Semaphores (ideally statically)
 *
 * TODO(gsound): move this macro to a GSound "application specific" layer
 *               header file since the number of semaphores required will
 *               depend on the application. Macro should still be released in
 *               source form to 3P
 */
#define GSOUND_TARGET_OS_SEMAPHORE_MAX 2

/**
 * Generic handle to a Semaphore type.
 * Target can use this to point to a memory location
 * or index into a table.
 */
typedef void *GSoundTargetSemaphoreHandle;

/**
 * Reserve/allocate and initialize a new Counting Semaphore.
 *
 * Ideally, target layer has GSOUND_TARGET_OS_SEMAPHORE_MAX number of semaphores
 * statically allocated at compile time. Target is also free to dynamically
 * allocate semaphores if desired.
 *
 * GSound will call this API to retrieve one of these Semaphores.
 *
 * This function should return a new Semaphore every time it is called until
 * it runs out at which point it should assert
 *
 * param[out]: id           GSoundTargetSemaphoreHandle opaque data type which
 *                          GSound will use to reference the Semaphore
 * param[in]: max_count     Max count that should be allowed by counting semaphore.
 * param[in]: initial_count Initial count of semaphore
 */
GSoundStatus GSoundTargetOsSemaphoreReserve(GSoundTargetSemaphoreHandle *id,
                                            uint32_t max_count,
                                            uint32_t initial_count);

/**
 * Waits on provided Semaphore until available.
 * This API should not timeout. Should never be called from ISR
 *
 * param[in]: id GSoundTargetSemaphoreHandle opaque data type referencing
 *               Semaphore to wait on
 */
GSoundStatus GSoundTargetOsSemaphoreWait(GSoundTargetSemaphoreHandle id);

/**
 * Posts / increment provided Semaphore.
 *
 * param[in]: id GSoundTargetSemaphoreHandle opaque data type referencing
 *               Semaphore to post
 */
GSoundStatus GSoundTargetOsSemaphorePost(GSoundTargetSemaphoreHandle id);

/******************************************************************************
 * Thread
 ******************************************************************************/

/**
 * Identifies whether the caller is running on the GSound
 * thread or not.
 *
 * Returns: true, if caller is executing out of GSound thread
 *          false, if caller is execute out of any other context
 */
bool GSoundTargetOsMqActive(void);

/**
 * Thread entry function type
 */
typedef void (*GSoundTargetOsThreadEntry)(void);

/**
 * Create and start a thread
 */
GSoundStatus GSoundTargetOsThreadInit(GSoundTargetOsThreadEntry entry);

/******************************************************************************
 * Interrupt Locks
 *****************************************************************************/

/**
 * Disable global interrupts.
 *
 * The function returns the state of the global interrupts (on or off)
 * prior to disabling. This will be used to restore interrupts
 *
 * return value can be opaque to caller
 */
uint32_t GSoundTargetOsIntLock(void);

/**
 * Revert interrupts give the last state.
 *
 * param[in]: int_status An opaque type returned from
 *                       GSoundTargetOsIntLock.
 */
void GSoundTargetOsIntRevert(uint32_t int_status);

/******************************************************************************
 * Timers
 *****************************************************************************/

/**
 * Return a free running counter in milliseconds.
 *
 * Counter should be free running from boot-up
 * and is not expected to roll over. Accuracy
 * of timer is not critical.
 */
uint32_t GSoundTargetOsGetTicksMs(void);

#ifdef __cplusplus
}
#endif

#endif  // GSOUND_TARGET_OSA_H
